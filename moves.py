import numpy as np
import logging

from funcs import check_position
from path import Path

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

def shooting_move(ens):
    """ Performs a shooting move in the ensemble.

    A random phasepoint of the last_accepted path in the ensemble is chosen,
    excluding the first and last phasepoints. This new phasepoint, called the
    shootpoint, is given new velocities drawn from the Maxwell-Boltzmann
    distribution. A new path is generated by propagating the shootpoint
    backwards and forwards in time. Note that backwards propagation is done
    by reversing the velocities of the shootpoint.

    To obey detailed balance, the new path is accepted with probability
    min(1, len(old_path)/len(new_path)). For efficiency sake, we draw a random
    number between 0 and 1 and propagate the new_path until len(old_path)/Q.

    The new_path is checked whether it is an acceptable path for the ensemble.

    Parameters
    ----------
    ens : :py:class:`Ensemble` object
        Ensemble in which the shooting move is performed

    Returns
    -------
    success : string
        String indicating whether the shooting move was successful
    new_path : :py:class:`Path` object
        New path generated by the shooting move

    """

    path = ens.paths[0]  # last accepted path
    pathlen = len(path.phasepoints)
    shoot_maxlen = min(pathlen/np.random.random(), ens.max_len)
    shootpoint_pos = path.phasepoints[np.random.randint(1,pathlen-1)][0]
    shootpoint_vel = ens.engine.draw_velocities()
    shootpoint = (shootpoint_pos, shootpoint_vel)
    shootpoint_op = ens.orderparameter.calculate(shootpoint)

    logger.info("Shooting from ph {} with op {}".format(
        shootpoint, shootpoint_op))

    # We now start propagating the shootpoint backwards first, because often
    # the backwards part (corresponding to the starting condition) is more
    # restrictive than the forwards part (corresponding to the end condition).
    temp_path = []
    temp_path_op = []
    run_worthy = True
    run_len = 1  # we already have one phasepoint (shootpoint)
    ph = (shootpoint_pos, -1.*shootpoint_vel)
    crossed_bw = False
    while run_worthy:
        logger.debug("Propagating backwards")
        ph = ens.engine.step(ph)
        op = ens.orderparameter.calculate(ph)
        logger.debug(f"ph: {ph}, op: {op}")
        temp_path.append((ph[0], -1.*ph[1]))  # re-reverse the velcities!
        temp_path_op.append(op)
        run_len += 1
        LR_posB = check_position(op, ens.intfs['L'], ens.intfs['R'])
        if LR_posB in ['L', 'R']:
            run_worthy = False
            if LR_posB in ens.start_conditions:
                msg = f"Backwards crossed {LR_posB}, which is part of the start"
                msg+= f" conditions {ens.start_conditions}"
                logger.debug(msg)
                crossed_bw = True
            else:
                msg = f"Backwards crossed {LR_posB}, which is not part of the"
                msg+= f" start conditions {ens.start_conditions}"
                logger.debug(msg)
                logger.debug("Backwards part hit the wrong interface.")
                return "BWI", Path(temp_path, temp_path_op)
        if run_len >= shoot_maxlen and not crossed_bw:
            msg = f"Backwards part too long ({run_len} >= {shoot_maxlen})"
            logger.debug(msg)
            return "BTL", Path(temp_path, temp_path_op)

    temp_path = temp_path[::-1] + [shootpoint]  # reverse backwards part
    temp_path_op = temp_path_op[::-1] + [shootpoint_op]
    # Now we propagate the shootpoint forwards
    ph = shootpoint
    run_worthy = True
    crossed_fw = False
    while run_worthy:
        logger.debug("Propagating forwards")
        ph = ens.engine.step(ph)
        op = ens.orderparameter.calculate(ph)
        logger.debug(f"ph: {ph}, op: {op}")
        temp_path.append(ph)
        temp_path_op.append(op)
        run_len += 1
        LR_posF = check_position(op, ens.intfs['L'], ens.intfs['R'])
        if LR_posF in ['L', 'R']:
            run_worthy = False
            if LR_posF in ens.end_conditions:
                msg = f"Forwards crossed {LR_posF}, which is part of the end"
                msg+= f" conditions {ens.end_conditions}"
                logger.debug(msg)
                crossed_fw = True
            else:
                msg = f"Forwards crossed {LR_posF}, which is not part of the"
                msg+= f" end conditions {ens.end_conditions}"
                logger.debug(msg)
                logger.debug("Forwards part hit the wrong interface.")
                return "FWI", Path(temp_path, temp_path_op)
        if run_len >= shoot_maxlen and not crossed_fw:
            msg = f"Forwards part too long ({run_len} >= {shoot_maxlen})"
            logger.debug(msg)
            return "FTL", Path(temp_path, temp_path_op)

    # If we reached this point, we have a new path. We now check whether it
    # satisfies the crossing conditions.
    new_path = Path(temp_path, temp_path_op)
    if not ens.check_cross(new_path):
        logger.debug("New shootpath does not satisfy crossing conditions")
        return "NCR", Path(temp_path, temp_path_op)
    else:
        logger.debug("New shootpath is acceptable.")
        return "ACC", new_path

def swap(ensembles, idx):
    """ Performs a swap move between the last paths of two ensembles.
    This (for now) only makes sense for (RE)TIS simulations. We only have to
    check whether the path of ensembles[idx] satisfies the crossing conditions
    of ensembles[idx+1].

    Parameters
    ----------
    ensembles: list of :py:class:`Ensemble` objects
        List of ensembles present in the simulation
    idx: int
        Index of the ensemble to swap with the next ensemble in the list

    Returns
    -------
    success : boolean
        Boolean indicating whether the swap move was successful
    """

    if ensembles[idx+1].check_path(ensembles[idx].paths[0]):
        return "ACC", ensembles[idx+1].last_path, ensembles[idx].last_path
    else:
        return "NCR", ensembles[idx+1].last_path, ensembles[idx].last_path

def swap_zero(ensembles):
    """ Performs a swap move between the [0^-] (or [0^-']) and [0^+] (or [0^+'])
    ensembles. This requires integration.

    The path of the [0^-] ensemble is extended into the [0^+] ensemble by
    propagating the last path forwards in time. We keep the last two
    phasepoints of [0^+], and extend starting from the last phasepoint.
    The path of the [0^+] ensemble is extended into the [0^-] ensemble
    by propagating the last path backwards in time. We keep the first two
    phasepoints of [0^-], and extend starting from the first phasepoint.

    Parameters
    ----------
    ensembles: list of :py:class:`Ensemble` objects
        List of ensembles present in the simulation

    Returns
    -------
    success : string
        String indicating whether the swap move was successful
    new_path_0m : :py:class:`Path` object
        New path of the [0^-] ensemble
    new_path_0p : :py:class:`Path` object
        New path of the [0^+] ensemble

    """
    ens0 = ensembles[0]
    ens1 = ensembles[1]
    temp_path_0p = [ens0.paths[0].phasepoints[i] for i in [-2, -1]]
    temp_path_0p_op = [ens0.paths[0].orders[i] for i in [-2, -1]]
    run_worthy = True
    ph = ens0.paths[0].phasepoints[-1]
    logger.debug("Propagating fw from ph {}".format(ph))
    run_len = 2
    crossed = False
    while run_worthy:
        ph = ens1.engine.step(ph)
        op = ens1.orderparameter.calculate(ph)
        temp_path_0p.append(ph)
        temp_path_0p_op.append(op)
        run_len += 1
        LR_pos = check_position(op, ens1.intfs['L'], ens1.intfs['R'])
        if LR_pos in ['L', 'R']:
            run_worthy = False
            if LR_pos in ens1.end_conditions:
                logger.debug(f"Path crossed {LR_pos}, which is part of the end")
                logger.debug(f"conditions {ens1.end_conditions}")
                crossed = True
            else:
                logger.debug(f"Path crossed {LR_pos}, which is not part of the")
                logger.debug(f"end conditions {ens1.end_conditions}")
                logger.debug("Path hit the wrong interface.")
                return "FWI", ens0.last_path,\
                    Path(temp_path_0p, temp_path_0p_op, ens1.id)
        if run_len >= ens1.max_len and not crossed:
            logger.debug(f"Path too long ({run_len} >= {ens1.max_len})")
            return "FTL", ens0.last_path,\
                Path(temp_path_0p, temp_path_0p_op, ens1.id)

    temp_path_0m = [ens1.paths[0].phasepoints[i] for i in [1, 0]]
    temp_path_0m_op = [ens1.paths[0].orders[i] for i in [1, 0]]
    run_worthy = True
    ph = ens1.paths[0].phasepoints[0]
    ph = (ph[0], -1.*ph[1])  #@ Reverse the velocities!
    logger.debug("Propagating bw from ph {}".format(ph))
    run_len = 2
    crossed = False
    while run_worthy:
        ph = ens0.engine.step(ph)
        op = ens0.orderparameter.calculate(ph)
        temp_path_0m.append((ph[0], -1.*ph[1]))
        temp_path_0m_op.append(op)
        run_len += 1
        LR_pos = check_position(op, ens0.intfs['L'], ens0.intfs['R'])
        if LR_pos in ['L', 'R']:
            run_worthy = False
            if LR_pos in ens0.start_conditions:
                logger.debug(f"Path crossed {LR_pos}, which is part of the")
                logger.debug(f"start conditions {ens0.start_conditions}")
                crossed = True
            else:
                logger.debug(f"Path crossed {LR_pos}, which is not part of the")
                logger.debug(f"start conditions {ens0.start_conditions}")
                logger.debug("Path hit the wrong interface.")
                return "BWI", Path(temp_path_0m, temp_path_0m_op, ens0.id),\
                    Path(temp_path_0p, temp_path_0p_op, ens1.id)
        if run_len > ens0.max_len and not crossed:
            logger.debug(f"Path too long ({run_len} >= {ens0.max_len})")
            return "BTL", Path(temp_path_0m, temp_path_0m_op, ens0.id),\
                Path(temp_path_0p, temp_path_0p_op, ens1.id)

    new_path_0p = Path(temp_path_0p, temp_path_0p_op)
    new_path_0m = Path(temp_path_0m[::-1], temp_path_0m_op[::-1])
    if not ens0.check_cross(new_path_0m):
        logger.debug("New path 0m does not satisfy crossing conditions")
        return "NCR", new_path_0m, new_path_0p
    if not ens1.check_cross(new_path_0p):
        logger.debug("New path 0p does not satisfy crossing conditions")
        return "NCR", new_path_0m, new_path_0p
    else:
        logger.debug("New paths are acceptable.")
        return "ACC", new_path_0m, new_path_0p

def repptis_swap(ensembles, idx):
    """ Performs a swapping move in REPPTIS simulations, between adjacent
    PPTIS ensembles. First, propagation directiosn are randomly chosen for both
    paths, and it is checked whether the pathtypes (i.e. LMR, RMR, ...) are
    compatible. If not, the move is rejected. If the proposed directions are
    compatible with the pathytpes, then the path segments in the overalapping
    region are cut, and they are propagated in the proposed directions.

    For compatible propagation directoins, the paths are created as follows:
    1) new [i^+-] path from old [(i+1)^+-] path. The path segment in the 'LM'
    region is cut out of the old [(i+1)^+-] path (with one point left of the
    L interface, and one point right of the M interface). This path segment is
    then extended by propagating the phasepoint left of the L interface in the
    proposed direction until a crossing condition of the [i^+-] inteface occurs.

    2) new [(i+1)^+-] path from old [i^+-] path. The path segment in the 'MR'
    region is cut out of the old [i^+-] path (with one point left of the M
    interface, and one point right of the R interface). This path segment is
    then extended by propagating the phasepoint right of the R interface in the
    proposed direction until a crossing condition of the [(i+1)^+-] inteface
    occurs.

    Note about overlap_part:
        Standard behaviour is to include the shootpoint, otherwise it may
        change be recalculating the orderparamater, and create potential
        problems by shifting position along an interface.

    Parameters
    ----------
    ensembles: list of :py:class:`Ensemble` objects
        List of ensembles present in the simulation
    idx: int
        The index of the ensemble whose path is swapped with the path of the
        next ensemble in the list

    """
    logger.info("Swapping: {} <-> {}".format(idx, idx+1))

    # if idx == 0, we perform a swap_zero move
    if idx == 0:
        return swap_zero(ensembles)

    # Else, we do the repptis swap. This is very similar to the swap_zero move,
    # but we have to be careful about the path types.
    ens0 = ensembles[idx]
    ens1 = ensembles[idx+1]

    # Choose propagation directions for the two paths, and check if the proposed
    # move is allowed or not
    allowed, propdir0, propdir1, path0_type, path1_type = \
        check_propagation_directions(ens0, ens1)

    if not allowed:
        msg = "Proposed move is not allowed. Incompatible path types and "
        msg += "propagation directions."
        logger.debug(msg)
        return 'SWD', ens0.last_path, ens1.last_path  # Swap Wrong Direction

    # If allowed, the swap move is attempted
    msg = "Attempting swap of {} and {} paths with propdirs {} and {}."
    logger.debug(msg.format(path0_type, path1_type, propdir0, propdir1))

    # First create path0_new, then path1_new.
    # We will immediately reject the move if path0_new is not valid.

    # 1) new [i^+-] path from old [(i+1)^+-] path
    ph_overlap0, op_overlap0, sh0 = \
        cut_overlap_phasepoints(ens1, propdir1, side='right')
    # now we can propagate the phasepoint sh0 in the proposed direction
    if ens0.ens_type == 'PPTIS_0plusmin_primed':  # Automatically acceptable
        new_path_0 = Path(ph_overlap0, op_overlap0, ens0.id)
        status0 = "ACC"   
    else:
        ph_extend0, op_extend0 = [], []
        run_len = len(ph_overlap0)
        crossed = False
        run_worthy = True
        reverser0 = 1. if propdir1 == 'forwards' else -1.
        ph = (sh0[0], reverser0*sh0[1])
        while run_worthy:
            ph = ens0.engine.step(ph)
            op = ens0.orderparameter.calculate(ph)
            ph_extend0.append((ph[0], reverser0*ph[1]))
            op_extend0.append(op)
            run_len += 1
            LR_pos = check_position(op, ens0.intfs['L'], ens0.intfs['R'])
            if LR_pos in ['L', 'R']:
                run_worthy = False
                if LR_pos in ens0.end_conditions if reverser0 == 1. else \
                        ens0.start_conditions:
                    msg = f"Path crossed {LR_pos}, which is part of the"
                    msg+= "{}".format("end" if reverser0 == 1. else "start")
                    msg+= " conditions {}".format(ens0.end_conditions if \
                                reverser0 == 1. else ens0.start_conditions)
                    logger.debug(msg)
                    crossed = True
                    status0 = "ACC"
                else:
                    msg = f"Path crossed {LR_pos}, which is not part of the"
                    msg+= "{}".format("end" if reverser0 == 1. else "start")
                    msg+= " conditions {}".format(ens0.end_conditions if \
                                reverser0 == 1. else ens0.start_conditions)
                    logger.debug(msg)
                    logger.debug("Path hit the wrong interface.")
                    status0 = "FWI" if reverser0 == 1. else "BWI"
            if run_len >= ens0.max_len and not crossed:
                logger.debug(f"Path too long ({run_len} >= {ens0.max_len})")
                status0 = "FTL" if reverser0 == 1. else "BTL"

    if status0 != "ACC":
        logger.info("First propagation was not succussful. Reason: {}".format(
            status0))
        if reverser0 == -1.:
            trial0 = Path(ph_extend0[::-1] + ph_overlap0,
                          op_extend0[::-1] + op_overlap0,
                          ens0.id)
        else:
            trial0 = Path(ph_overlap0 + ph_extend0,
                          op_overlap0 + op_extend0,
                          ens0.id)
        return status0, trial0, ens1.last_path

    # 2) new [(i+1)^+-] path from old [i^+-] path
    ph_overlap1, op_overlap1, sh1 = \
        cut_overlap_phasepoints(ens0, propdir0, side='left')
    # now we can propagate the phasepoint sh1 in the proposed direction
    run_len = len(ph_overlap1)
    crossed = False
    run_worthy = True
    reverser1 = 1. if propdir0 == 'forwards' else -1.
    ph = (sh1[0], reverser1*sh1[1])
    ph_extend1, op_extend1 = [], []
    while run_worthy:
        ph = ens1.engine.step(ph)
        op = ens1.orderparameter.calculate(ph)
        ph_extend1.append((ph[0], reverser1*ph[1]))
        op_extend1.append(op)
        run_len += 1
        LR_pos = check_position(op, ens1.intfs['L'], ens1.intfs['R'])
        if LR_pos in ['L', 'R']:
            run_worthy = False
            if LR_pos in ens1.end_conditions if reverser1 == 1. else \
                    ens1.start_conditions:
                msg = f"Path crossed {LR_pos}, which is part of the"
                msg+= "{}".format("end" if reverser1 == 1. else "start")
                msg+= " conditions {}".format(ens1.end_conditions if \
                            reverser1 == 1. else ens1.start_conditions)
                logger.debug(msg)
                crossed = True
                status1 = "ACC"
            else:
                msg = f"Path crossed {LR_pos}, which is not part of the"
                msg+= "{}".format("end" if reverser1 == 1. else "start")
                msg+= " conditions {}".format(ens1.end_conditions if \
                            reverser1 == 1. else ens1.start_conditions)
                logger.debug(msg)
                logger.debug("Path hit the wrong interface.")
                status1 = "FWI" if reverser1 == 1. else "BWI"
        if run_len >= ens1.max_len and not crossed:
            logger.debug(f"Path too long ({run_len} >= {ens1.max_len})")
            status1 = "FTL" if reverser1 == 1. else "BTL"

    if status1 != "ACC":
        logger.info("Second propagation was not succussful. Reason: {}".format(
            status1))
        if reverser1 == -1.:
            trial1 = Path(ph_extend1[::-1] + ph_overlap1,
                          op_extend1[::-1] + op_overlap1,
                          ens1.id)
        else:
            trial1 = Path(ph_overlap1 + ph_extend1,
                          op_overlap1 + op_extend1,
                          ens1.id)
        return status1, trial0, trial1

    # If we reached this point, we have two new paths. We now check whether they
    # satisfy the crossing conditions.
    if reverser0 == -1.:
        new_path_0 = Path(ph_extend0[::-1] + ph_overlap0,
                          op_extend0[::-1] + op_overlap0,
                          ens0.id)
    else:
        new_path_0 = Path(ph_overlap0 + ph_extend0,
                          op_overlap0 + op_extend0,
                          ens0.id)
    if reverser1 == -1.:
        new_path_1 = Path(ph_extend1[::-1] + ph_overlap1,
                          op_extend1[::-1] + op_overlap1,
                          ens1.id)
    else:
        new_path_1 = Path(ph_overlap1 + ph_extend1,
                          op_overlap1 + op_extend1,
                          ens1.id)

    if not ens0.check_path(new_path_0):
        logger.warning("New path does not satisfy ensemble conditions.")
        return "NCR", new_path_0, new_path_1
    if not ens1.check_cross(new_path_1):
        logger.warning("New path does not satisfy ensemble conditions.")
        return "NCR", new_path_0, new_path_1
    else:
        logger.debug("New paths are acceptable.")
        return "ACC", new_path_0, new_path_1

def cut_overlap_phasepoints(ens, propdir, side):
    """ Cut the phasepoints in the overlapping region of two PPTIS ensembles.

    Parameters
    ----------
    ens: :py:class:`Ensemble` object
        Ensemble whose path is cut
    propdir: str
        Propagation direction of the path. Forwards or backwards
    side: string
        This is either 'left' or 'right', and denotes the side from which
        the path originates. left: [i^+-] path to be propagated into [i+1^+-],
        right: [(i+1)^+-] path to be propagated into [i^+-].

    Returns
    -------
    phasepoints_overlap : list of phasepoints
        The phasepoints in the overlap region
    shootpoint : phasepoint
        The phasepoint from which the propagation will start.

    Notes
    -----
    Note that here we need to re-reverse paths that are reversed,
    as we are not using the 'paste-paths' function from pyretis...

    Note that this function assumes that the proposed combination of 
    propdir and side makes sense for ens.last_path...

    """
    # intf_M defines when to stop cutting phasepoints, starting from a L or R
    # interface. For now, this only differs from M in the case of a [0^+-']

    intf_M = ens.intfs['M'] if not ens.ens_type == 'PPTIS_0plusmin_primed' \
            else ens.intfs['L']
    phasepoints_overlap = []
    orders_overlap = []
    include_shootpoint = True  # standard behaviour

    if side == 'right':
        if propdir == 'backwards':
            shoot_point = ens.paths[0].phasepoints[0]
            if include_shootpoint:
                phasepoints_overlap.append(shoot_point)
                orders_overlap.append(ens.paths[0].orders[0])
            phase_points = ens.paths[0].phasepoints[1:]
            orders = ens.paths[0].orders[1:]
            for phase_point, order in zip(phase_points, orders):
                phasepoints_overlap.append(phase_point)
                orders_overlap.append(order)
                if order[0] > intf_M:  # if > M, we stop cutting
                    break
        elif propdir == 'forwards':
            shoot_point = ens.paths[0].phasepoints[-1]
            if include_shootpoint:
                phasepoints_overlap.append(shoot_point)
                orders_overlap.append(ens.paths[0].orders[-1])
            phase_points = ens.paths[0].phasepoints[:-1]
            orders = ens.paths[0].orders[:-1]
            for phase_point, order in zip(reversed(phase_points),
                                          reversed(orders)):
                phasepoints_overlap.append(phase_point)
                orders_overlap.append(order)
                if order[0] > intf_M:
                    break
            # re-reverse the phasepoints and orders
            phasepoints_overlap = phasepoints_overlap[::-1]
            orders_overlap = orders_overlap[::-1]
    elif side == 'left':
        if propdir == 'backwards':
            shoot_point = ens.paths[0].phasepoints[0]
            if include_shootpoint:
                phasepoints_overlap.append(shoot_point)
                orders_overlap.append(ens.paths[0].orders[0])
            phase_points = ens.paths[0].phasepoints[1:]
            orders = ens.paths[0].orders[1:]
            for phase_point, order in zip(phase_points, orders):
                phasepoints_overlap.append(phase_point)
                orders_overlap.append(order)
                if order[0] < intf_M:
                    break
        elif propdir == 'forwards':
            shoot_point = ens.paths[0].phasepoints[-1]
            if include_shootpoint:
                phasepoints_overlap.append(shoot_point)
                orders_overlap.append(ens.paths[0].orders[-1])
            phase_points = ens.paths[0].phasepoints[:-1]
            orders = ens.paths[0].orders[:-1]
            for phase_point, order in zip(reversed(phase_points),
                                          reversed(orders)):
                phasepoints_overlap.append(phase_point)
                orders_overlap.append(order)
                if order[0] < intf_M:
                    break
            # re-reverse the phasepoints and orders
            phasepoints_overlap = phasepoints_overlap[::-1]
            orders_overlap = orders_overlap[::-1]
    return phasepoints_overlap, orders_overlap, shoot_point

def check_propagation_directions(ens0, ens1):
    """ Proposes propagtion directions for the [i^+-] and [(i+1)^+-] paths, and
    checks whether this results in an acceptable swapping move.

    Parameters
    ----------
    ens0, ens1: :py:class:`Ensemble` objects
        The two ensembles whose paths are swapped

    Returns
    -------
    allowed: bool
        Whether the proposed move is allowed or not
    propdir0, propdir1: str
        The proposed propagation directions for the two paths
    path0_type, path1_type: str
        The path types of the two paths

    """
    # Check the position of the start and end points of the two paths
    start0_pos, end0_pos = ens0.check_start_end_positions(ens0.paths[0])
    start1_pos, end1_pos = ens1.check_start_end_positions(ens1.paths[0])
    p0type = start0_pos + "M" + end0_pos
    p1type = start1_pos + "M" + end1_pos
    propdir0 = ['backwards','forwards'][round(np.random.rand())]
    propdir1 = ['backwards','forwards'][round(np.random.rand())]

    # check if the proposed move is allowed
    allow = {'leftright': {'L': False, 'R': True},
             'rightleft': {'L': True, 'R': False}}
    allowed0 = allow['leftright'][start0_pos if propdir0 == 'backwards' \
                                  else end0_pos]
    allowed1 = allow['rightleft'][start1_pos if propdir1 == 'backwards' \
                                  else end1_pos]
    allowed = allowed0 and allowed1

    # log the move
    msg = "Proposed swap move:\n"
    msg+= f"{ens0.name} ({ens0.id}) <--> {ens1.name} ({ens1.id})\n"
    msg+= f"Proposed directions: {propdir0} <-> {propdir1}\n"
    msg+= f"Path types: {p0type} <-> {p1type}"
    logger.info(msg)

    return allowed, propdir0, propdir1, p0type, p1type

