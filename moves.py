import numpy as np
import logging

from funcs import check_position
from path import Path

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

def shooting_move(ens, level=0):
    """ Performs a shooting move in the ensemble.

    A random phasepoint of the last_accepted path in the ensemble is chosen,
    excluding the first and last phasepoints. This new phasepoint, called the
    shootpoint, is given new velocities drawn from the Maxwell-Boltzmann
    distribution. A new path is generated by propagating the shootpoint
    backwards and forwards in time. Note that backwards propagation is done
    by reversing the velocities of the shootpoint.

    To obey detailed balance, the new path is accepted with probability
    min(1, len(old_path)/len(new_path)). For efficiency sake, we draw a random
    number between 0 and 1 and propagate the new_path until len(old_path)/Q.

    The new_path is checked whether it is an acceptable path for the ensemble.

    Parameters
    ----------
    ens : :py:class:`Ensemble` object
        Ensemble in which the shooting move is performed
    level : int
        The level of the path to shoot from in ensemble ens. Default is 0.

    Returns
    -------
    success : string
        String indicating whether the shooting move was successful
    new_path : :py:class:`Path` object
        New path generated by the shooting move

    """
    path = ens.paths[level]  # last accepted path
    pathlen = len(path.phasepoints)
    shoot_maxlen = min(pathlen/np.random.random(), ens.max_len)
    sh_id = np.random.randint(1,pathlen-1)
    shootpoint = (path.phasepoints[sh_id][0],
                  ens.engine.draw_velocities())
    # We will not recalculate the orderparameter for this phasepoint, as 
    # external engines may save phasepoints at a lower precision. This can 
    # lead to the recalculated phasepoint shifting position w.r.t. an interface,
    # resulting in all sorts of nasty problems.
    # shootpoint_op = ens.orderparameter.calculate(shootpoint)
    shootpoint_op = path.orders[sh_id]
    logger.debug("Shooting from ph {} (idx: {}) with op {}".format(
        shootpoint, sh_id, shootpoint_op))
    # We now start propagating the shootpoint backwards first, because often
    # the backwards part (corresponding to the starting condition) is more
    # restrictive than the forwards part (corresponding to the end condition).
    # propagate backwards. Maxlen = shoot_maxlen-1, because shootpoint is 1
    bw_status, bw_tuple = propagate(ens, shootpoint, -1., shoot_maxlen-1)
    # if unsuccessful, return the status and the partially propagated path
    if bw_status != "ACC": 
        logger.debug("Backwards propagation not successful: {}".format(
            bw_status))
        return bw_status, Path(bw_tuple[0]+[shootpoint],
                               bw_tuple[1]+[shootpoint_op],
                               ens.id)
    # if successful, we continue propagating forwards
    fw_status, fw_tuple = propagate(ens, shootpoint, 1.,
                                    shoot_maxlen-len(bw_tuple[0]))
    # if unsuccessful, return the status and the partially propagated path
    if fw_status != "ACC":
        logger.debug("Forwards propagation not successful: {}".format(
            fw_status))
        return fw_status, Path(bw_tuple[0] + [shootpoint] + fw_tuple[0],
                               bw_tuple[1] + [shootpoint_op] + fw_tuple[1],
                               ens.id)
    # If succesful, the new path should satisfy the crossing conditions.
    # logger.debug("Time origin of new path: {}".format(len(bw_tuple[0])-sh_id))
    new_path = Path(bw_tuple[0] + [shootpoint] + fw_tuple[0],
                    bw_tuple[1] + [shootpoint_op] + fw_tuple[1],
                    ens.id)
    # if the ensemble is a primed PPTIS ensemble, we have to check whether an 
    # illegal pathtype has occurred. If so, we reject the move with flag 'ILL'. 
    if ens.ens_type in ['PPTIS_0plusmin_primed', 'PPTIS_Nplusmin_primed']:
        ptype = ens.get_ptype(new_path)
        if ptype in ens.illegal_pathtypes:
            logger.info("Illegal pathtype {} for primed ensemble".format(ptype))
            return "ILL", new_path
    # We have to check whether the new path satisfies the crossing conditions.
    # TODO: all the above can be done in 'check_path' method of Ensemble, which 
    # should be rebuilt for this purpose. 
    if not ens.check_cross(new_path):
        logger.debug("New path does not satisfy ensemble crossing conditions")
        return "NCR", new_path
    else:
        logger.debug("New path satisfies ensemble crossing conditions.")
        return "ACC", new_path

def swap(ensembles, idx):
    """ Performs a swap move between the last paths of two ensembles.
    This (for now) only makes sense for (RE)TIS simulations. We only have to
    check whether the path of ensembles[idx] satisfies the crossing conditions
    of ensembles[idx+1].

    Parameters
    ----------
    ensembles: list of :py:class:`Ensemble` objects
        List of ensembles present in the simulation
    idx: int
        Index of the ensemble to swap with the next ensemble in the list

    Returns
    -------
    success : boolean
        Boolean indicating whether the swap move was successful

    """
    if ensembles[idx+1].check_path(ensembles[idx].paths[0]):
        return "ACC", ensembles[idx+1].paths[0], ensembles[idx].paths[0]
    else:
        return "NCR", ensembles[idx+1].paths[0], ensembles[idx].paths[0]

def swap_zero(ensembles):
    """ Performs a swap move between the [0^-] (or [0^-']) and [0^+] (or [0^+'])
    ensembles. This requires integration.

    The path of the [0^-] ensemble is extended into the [0^+] ensemble by
    propagating the last path forwards in time. We keep the last two
    phasepoints of [0^+], and extend starting from the last phasepoint.
    The path of the [0^+] ensemble is extended into the [0^-] ensemble
    by propagating the last path backwards in time. We keep the first two
    phasepoints of [0^-], and extend starting from the first phasepoint.

    Parameters
    ----------
    ensembles: list of :py:class:`Ensemble` objects
        List of ensembles present in the simulation

    Returns
    -------
    success : string
        String indicating whether the swap move was successful
    new_path_0m : :py:class:`Path` object
        New path of the [0^-] ensemble
    new_path_0p : :py:class:`Path` object
        New path of the [0^+] ensemble

    """
    ens0, ens1 = ensembles[0], ensembles[1]
    # 1. create the new path for the [0^+] ensemble.
    # Cut the last two phasepoints of the [0^-] path, and propagate the last
    # phasepoint forwards in time. Remember, the shoot phasepoint is already
    # present in ph1 and op1 via cut_extremal_phasepoints.
    ph1, op1, sh1 = cut_extremal_phasepoints(ens0, 1.)
    status1, tuple1 = propagate(ens1, sh1, 1., ens1.max_len - 2)
    # If not successful, return the status and the partially propagated path
    if status1 != "ACC":
        logger.debug("Forwards propagation not successful: {}".format(status1))
        return status1, ens1.paths[0], Path(ph1 + tuple1[0],
                                            op1 + tuple1[1],
                                            ens1.id)
    # If successful, the new path should satisfy the crossing conditions.
    new_path1 = Path(ph1 + tuple1[0], op1 + tuple1[1], ens1.id)
    if not ens1.check_cross(new_path1):
        logger.warning("New path [0^+] doesn't satisfy ens cross conditions")
        return "NCR", ens1.paths[0], new_path1
    # 2. create the new path for the [0^-] ensemble.
    # Cut the first two phasepoints of the [0^+] path, and propagate the first
    # phasepoint backwards in time. Remember, the shoot phasepoint is already
    # present in ph0 and op0 via cut_extremal_phasepoints.
    ph0, op0, sh0 = cut_extremal_phasepoints(ens1, -1.)
    status0, tuple0 = propagate(ens0, sh0, -1., ens0.max_len - 2)
    # If not successful, return the status and the partially propagated path
    if status0 != "ACC":
        logger.debug("Backwards propagation not successful: {}".format(status0))
        return status0, Path(tuple0[0] + ph0, tuple0[1] + op0, ens0.id),\
            new_path1
    # If successful, the new path should satisfy the crossing conditions.
    new_path0 = Path(tuple0[0] + ph0, tuple0[1] + op0, ens0.id)
    if not ens0.check_cross(new_path0):
        logger.warning("New path [0^-] doesn't satisfy ens cross conditions")
        return "NCR", new_path0, new_path1
    # If we reached this point, both new paths have been double checked, and we
    # return the accepted paths.
    return "ACC", new_path0, new_path1

def repptis_swap(ensembles, idx):
    """ Performs a swapping move in REPPTIS simulations, between adjacent
    PPTIS ensembles. First, propagation directions are randomly chosen for both
    paths, and it is checked whether the pathtypes (i.e. LMR, RMR, ...) are
    compatible. If not, the move is rejected. If the proposed directions are
    compatible with the pathtypes, then the path segments in the overalapping
    region are cut, and they are propagated in the proposed directions.

    For compatible propagation directions, the paths are created as follows:
    1) new [i^+-] path from old [(i+1)^+-] path. The path segment in the 'LM'
    region is cut out of the old [(i+1)^+-] path (with one point left of the
    L interface, and one point right of the M interface). This path segment is
    then extended by propagating the phasepoint left of the L interface in the
    proposed direction until a crossing condition of the [i^+-] inteface occurs.

    2) new [(i+1)^+-] path from old [i^+-] path. The path segment in the 'MR'
    region is cut out of the old [i^+-] path (with one point left of the M
    interface, and one point right of the R interface). This path segment is
    then extended by propagating the phasepoint right of the R interface in the
    proposed direction until a crossing condition of the [(i+1)^+-] inteface
    occurs.

    Note about overlap_part:
        Standard behaviour is to include the shootpoint, otherwise it may
        change be recalculating the orderparamater, and create potential
        problems by shifting position along an interface.

    Parameters
    ----------
    ensembles: list of :py:class:`Ensemble` objects
        List of ensembles present in the simulation
    idx: int
        The index of the ensemble whose path is swapped with the path of the
        next ensemble in the list

    """
    logger.info("Swapping: {} <-> {}".format(idx, idx+1))
    # if idx == 0, we perform a swap_zero move
    if idx == 0:
        return swap_zero(ensembles)
    # Else, we do the repptis swap. This is very similar to the swap_zero move,
    # but we have to be careful about the path types.
    ens0, ens1 = ensembles[idx], ensembles[idx+1]
    # Choose propagation directions for the two paths, and check if the proposed
    # move is allowed or not
    allowed, propdir0, propdir1, path0_type, path1_type = \
        check_propagation_directions(ens0, ens1)
    if not allowed:
        msg = "Proposed move is not allowed. Incompatible path types and "
        msg += "propagation directions."
        logger.debug(msg)
        return 'SWD', ens0.paths[0], ens1.paths[0]  # Swap Wrong Direction
    
    # If allowed, the swap move is attempted
    msg = "Attempting swap of {} and {} paths with propdirs {} and {}."
    logger.debug(msg.format(path0_type, path1_type, propdir0, propdir1))
    # we work with reverse = 1. for forwards propagation, and -1. for backwards
    reverse0 = 1. if propdir0 == 'forwards' else -1.
    reverse1 = 1. if propdir1 == 'forwards' else -1.

    # First create path0_new, then path1_new.
    # We will immediately reject the move if path0_new is not valid.
    # 1) new [i^+-] path from old [(i+1)^+-] path
    ph_overlap0, op_overlap0, sh0 = cut_LR_to_M(ens1, reverse1)
    # now we can propagate the phasepoint sh0 in the proposed direction
    if ens0.ens_type == 'PPTIS_0plusmin_primed':  # Automatically acceptable
        new_path_0 = Path(ph_overlap0, op_overlap0, ens0.id)
        status0 = "ACC"   
    else:
        status0, tuple0 = propagate(ens0, sh0, reverse1,
                                    ens0.max_len - len(ph_overlap0))
    # If not successful, return the status and the partially propagated paths
    if status0 != "ACC":
        logger.info("First propagation was not succussful. Reason: {}".format(
            status0))
        if reverse1 == -1.:
            trial0 = Path(tuple0[0] + ph_overlap0, tuple0[1] + op_overlap0,
                          ens0.id)
        else:
            trial0 = Path(ph_overlap0 + tuple0[0], op_overlap0 + tuple0[1],
                          ens0.id)
        return status0, trial0, ens1.paths[0]

    # 2) new [(i+1)^+-] path from old [i^+-] path
    ph_overlap1, op_overlap1, sh1 = cut_LR_to_M(ens0, reverse0)
    if ens1.ens_type == 'PPTIS_Nplusmin_primed':  # Automatically acceptable
        new_path_1 = Path(ph_overlap1, op_overlap1, ens1.id)
        status1 = "ACC"
    else:
        # now we can propagate the phasepoint sh1 in the proposed direction
        status1, tuple1 = propagate(ens1, sh1, reverse0,
                                    ens1.max_len - len(ph_overlap1))
    if status1 != "ACC":
        logger.info("Second propagation was not succussful. Reason: {}".format(
            status1))
        if reverse0 == -1.:
            trial1 = Path(tuple1[0] + ph_overlap1, tuple1[1] + op_overlap1,
                          ens1.id)
        else:
            trial1 = Path(ph_overlap1 + tuple1[0], op_overlap1 + tuple1[1],
                          ens1.id)
        return status1, trial0, trial1

    # If we reached this point, we have two new paths. We now check whether they
    # satisfy the crossing conditions.
    if ens0.ens_type != 'PPTIS_0plusmin_primed':  # 0+-: new_path_0 already made
        if reverse1 == -1.:
            new_path_0 = Path(tuple0[0] + ph_overlap0, tuple0[1] + op_overlap0,
                            ens0.id)
        else:
            new_path_0 = Path(ph_overlap0 + tuple0[0], op_overlap0 + tuple0[1],
                            ens0.id)
    if ens1.ens_type != 'PPTIS_Nplusmin_primed':  # N+-: new_path_1 already made
        if reverse0 == -1.:
            new_path_1 = Path(tuple1[0] + ph_overlap1, tuple1[1] + op_overlap1,
                            ens1.id)
        else:
            new_path_1 = Path(ph_overlap1 + tuple1[0], op_overlap1 + tuple1[1],
                            ens1.id)
    # IN_THE_END: now we keep it at warning level to not crash the program
    # assert ens0.check_path(new_path_0),\
    #     "New_path_0 for ens0 does not satisfy ensemble conditions."
    # assert ens1.check_path(new_path_1),\
    #     "New_path_1 for ens1 does not satisfy ensemble conditions."
    if not ens0.check_path(new_path_0):
        logger.warning("New path does not satisfy ensemble conditions.")
        return "NCR", new_path_0, new_path_1
    if not ens1.check_path(new_path_1):
        logger.warning("New path does not satisfy ensemble conditions.")
        return "NCR", new_path_0, new_path_1
    else:
        logger.debug("New paths are acceptable.")
        return "ACC", new_path_0, new_path_1

def cut_LR_to_M(ens, reverse, level=0, M=None):
    """A simplified version of cut_overlap_phasepoints. This function does the 
    same thing: cutting from the first (last) phasepoint until the M interface
    is reached. 

    Parameters
    ----------
    ens: :py:class:`Ensemble` object
        Ensemble whose path is cut
    reverse: float
        Whether to propagate forwards (1.) or backwards (-1.)
    level: int
        The level of the path to cut
    M: string
        The interface to cut to. If None, the M interface is set automatically
        to conform to the REPPTIS swap move.
    Returns
    -------
    phs: list of phasepoints
        The phasepoints in the overlap region
    ops: list of orderparameters
        The orderparameters in the overlap region
    shootpoint: phasepoint
        The phasepoint from which the propagation will start. 

    Notes
    -----
    This version includes the shootpoint in the returned phasepoints!!

    Cutting from the primed ensembles is hard-coded to work with the 
    REPPTIS SWAP MOVE **ONLY**.
    
    """
    # M defines when to stop cutting phasepoints, starting from a L or R
    # interface. These are specifically set for the REPPTIS swap move 
    # for the 0+- and N+- ensembles. Cutting a 
    if ens.ens_type == 'PPTIS_0plusmin_primed':
        M = ens.intfs['L']
    elif ens.ens_type == 'PPTIS_Nplusmin_primed':
        M = ens.intfs['R']
    else:
        M = ens.intfs['M']

    if reverse == -1:
        # extract shootpoint
        shootpoint = ens.paths[level].phasepoints[0]
        shootpoint_op = ens.paths[level].orders[0]
        # are we left or right of M?
        right_of_M = True if shootpoint_op[0] > M else False
        # start cutting
        phs, ops = [], []
        for ph, op in zip(ens.paths[level].phasepoints[1:],
                          ens.paths[level].orders[1:]):
            phs.append(ph)
            ops.append(op)
            if right_of_M and op[0] < M:
                break
            elif not right_of_M and op[0] > M:
                break
        # add the shootpoint
        phs = [shootpoint] + phs
        ops = [shootpoint_op] + ops
    elif reverse == 1:
        # extract shootpoint
        shootpoint = ens.paths[level].phasepoints[-1]
        shootpoint_op = ens.paths[level].orders[-1]
        # are we left or right of M?
        right_of_M = True if shootpoint_op[0] > M else False
        # start cutting
        phs, ops = [], []
        for ph, op in zip(reversed(ens.paths[level].phasepoints[:-1]),
                          reversed(ens.paths[level].orders[:-1])):
            phs.append(ph)
            ops.append(op)
            if right_of_M and op[0] < M:
                break
            elif not right_of_M and op[0] > M:
                break
        # re-reverse the phasepoints and orders
        phs = phs[::-1]
        ops = ops[::-1]
        # add the shootpoint
        phs = phs + [shootpoint]
        ops = ops + [shootpoint_op]
    else:
        raise ValueError("reverse must be either 1 or -1")
    
    return phs, ops, shootpoint

def check_propagation_directions(ens0, ens1):
    """ Proposes propagtion directions for the [i^+-] and [(i+1)^+-] paths, and
    checks whether this results in an acceptable swapping move.

    Parameters
    ----------
    ens0, ens1: :py:class:`Ensemble` objects
        The two ensembles whose paths are swapped

    Returns
    -------
    allowed: bool
        Whether the proposed move is allowed or not
    propdir0, propdir1: str
        The proposed propagation directions for the two paths
    path0_type, path1_type: str
        The path types of the two paths

    """
    # Check the position of the start and end points of the two paths
    start0_pos, end0_pos = ens0.check_start_end_positions(ens0.paths[0])
    start1_pos, end1_pos = ens1.check_start_end_positions(ens1.paths[0])
    p0type = start0_pos + "M" + end0_pos
    p1type = start1_pos + "M" + end1_pos
    propdir0 = ['backwards','forwards'][round(np.random.rand())]
    propdir1 = ['backwards','forwards'][round(np.random.rand())]

    # check if the proposed move is allowed
    allow = {'leftright': {'L': False, 'R': True},
             'rightleft': {'L': True, 'R': False}}
    allowed0 = allow['leftright'][start0_pos if propdir0 == 'backwards' \
                                  else end0_pos]
    allowed1 = allow['rightleft'][start1_pos if propdir1 == 'backwards' \
                                  else end1_pos]
    allowed = allowed0 and allowed1
    # extra check for the primed ensembles
    allowed2 = True
    if ens0.ens_type == 'PPTIS_0plusmin_primed':
        allowed2 = propdir1 == 'backwards'
    if ens1.ens_type == 'PPTIS_Nplusmin_primed':
        allowed2 = propdir0 == 'backwards'
    allowed = allowed and allowed2

    # log the move
    msg = "Proposed swap move:\n"
    msg+= f"{ens0.name} ({ens0.id}) <--> {ens1.name} ({ens1.id})\n"
    msg+= f"Proposed directions: {propdir0} <-> {propdir1}\n"
    msg+= f"Path types: {p0type} <-> {p1type}"
    logger.info(msg)

    return allowed, propdir0, propdir1, p0type, p1type

def propagate(ens, sh, reverse, maxlen):
    """Propagate from a phasepoint sh in ensemble ens, until either one of 
    the extremal conditions (ext_cond) is met, or the maximum length of the 
    path (maxlen) is reached.
    
    Parameters
    ----------
    ens : :py:class:`Ensemble` object
        Ensemble to propagate in
    sh : phasepoint 
        Phasepoint to propagate from (tuple (x,v))
    reverse : float 
        Whether to propagate forwards (1.) or backwards (-1.)
    maxlen : int
        Maximum length of the path to generate

    Returns
    -------
    status : str
        Status of the propagation.
    trial_tuple : tuple
        tuple of (phs, ops, ens.id) of the trial path

    Notes
    -----
    The returned path does **not** include the shooting point!

    """
    if reverse == -1:
        logger.debug("Propagating backwards")
        conds = {"cond": ens.start_conditions,
                 "rej_intf": "BWI",
                 "rej_maxlen": "BTL",
                 "type_cond": "start"}
    elif reverse == 1:
        logger.debug("Propagating forwards")
        conds = {"cond": ens.end_conditions,
                 "rej_intf": "FWI",
                 "rej_maxlen": "FTL",
                 "type_cond": "end"}
    else:
        raise ValueError("reverse must be either 1 or -1")

    phs, ops = [], []
    run_len = 0
    run_worthy = True
    ph = (sh[0], reverse*sh[1])
    while run_worthy:
        #logger.debug("ph = %s", ph)
        ph = ens.engine.step(ph)
        op = ens.orderparameter.calculate(ph)
        phs.append((ph[0], reverse*ph[1]))
        ops.append(op)
        run_len += 1
        LR_pos = check_position(op, ens.intfs['L'], ens.intfs['R'])
        if LR_pos in ens.extremal_conditions:
            run_worthy = False
            if LR_pos in conds['cond']:
                msg = f"Path crossed {LR_pos}, which is part of the "
                msg += f"{conds['type_cond']} conditions {conds['cond']}."
                logger.debug(msg)
                status = "ACC"
            else:
                msg = f"Path crossed {LR_pos}, which is not part of the "
                msg += f"{conds['type_cond']} conditions {conds['cond']}."
                logger.debug(msg)
                status = conds['rej_intf']
        elif run_len >= maxlen:
            logger.debug(f"Path too long ({run_len} >= {maxlen}).")
            status = conds['rej_maxlen']
            run_worthy = False
    
    if reverse == -1:
        trial_tuple = (phs[::-1], ops[::-1], ens.id)
    else:
        trial_tuple = (phs, ops, ens.id)

    return status, trial_tuple

def cut_extremal_phasepoints(ens, reverse, level=0):
    """Cuts and returns the two first or last phasepoints of the level L path
    of the ensemble ens, depending on whether we propagate backwards or 
    forwards, respectively. The two phasepoints are ordered in 'normal' time.

    Parameters
    ----------
    ens : :py:class:`Ensemble` object
        Ensemble in which we cut the extremal phasepoints
    reverse : float
        Whether to propagate forwards (1, cut last two phasepoints) or 
        backwards (-1, cut first two phasepoints)
    level : int
        Level of the path to cut. Level 0 is the last-accepted path, level 1
        is the second-last accepted path, etc.

    Returns
    -------
    ph_overlap : list of phasepoints
        List of the two phasepoints
    op_overlap : list of floats
        List of the two order parameters
    sh : phasepoint
        Shooting point to generate the new path
    """
    if reverse == -1:
        ph_overlap = [ens.paths[level].phasepoints[i] for i in [0, 1]]
        op_overlap = [ens.paths[level].orders[i] for i in [0, 1]]
        sh = ens.paths[level].phasepoints[0]
    elif reverse == 1:
        ph_overlap = [ens.paths[level].phasepoints[i] for i in [-2, -1]]
        op_overlap = [ens.paths[level].orders[i] for i in [-2, -1]]
        sh = ens.paths[level].phasepoints[-1]
    else:
        raise ValueError("reverse must be either 1 or -1")
    return ph_overlap, op_overlap, sh


###############################################################################
# OLD FUNCTIONS
###############################################################################
def repptis_swap_old(ensembles, idx):
    """ Performs a swapping move in REPPTIS simulations, between adjacent
    PPTIS ensembles. First, propagation directions are randomly chosen for both
    paths, and it is checked whether the pathtypes (i.e. LMR, RMR, ...) are
    compatible. If not, the move is rejected. If the proposed directions are
    compatible with the pathtypes, then the path segments in the overalapping
    region are cut, and they are propagated in the proposed directions.

    For compatible propagation directions, the paths are created as follows:
    1) new [i^+-] path from old [(i+1)^+-] path. The path segment in the 'LM'
    region is cut out of the old [(i+1)^+-] path (with one point left of the
    L interface, and one point right of the M interface). This path segment is
    then extended by propagating the phasepoint left of the L interface in the
    proposed direction until a crossing condition of the [i^+-] inteface occurs.

    2) new [(i+1)^+-] path from old [i^+-] path. The path segment in the 'MR'
    region is cut out of the old [i^+-] path (with one point left of the M
    interface, and one point right of the R interface). This path segment is
    then extended by propagating the phasepoint right of the R interface in the
    proposed direction until a crossing condition of the [(i+1)^+-] inteface
    occurs.

    Note about overlap_part:
        Standard behaviour is to include the shootpoint, otherwise it may
        change be recalculating the orderparamater, and create potential
        problems by shifting position along an interface.

    Parameters
    ----------
    ensembles: list of :py:class:`Ensemble` objects
        List of ensembles present in the simulation
    idx: int
        The index of the ensemble whose path is swapped with the path of the
        next ensemble in the list

    """
    logger.info("Swapping: {} <-> {}".format(idx, idx+1))
    # if idx == 0, we perform a swap_zero move
    if idx == 0:
        return swap_zero(ensembles)
    # Else, we do the repptis swap. This is very similar to the swap_zero move,
    # but we have to be careful about the path types.
    ens0, ens1 = ensembles[idx], ensembles[idx+1]
    # Choose propagation directions for the two paths, and check if the proposed
    # move is allowed or not
    allowed, propdir0, propdir1, path0_type, path1_type = \
        check_propagation_directions(ens0, ens1)
    if not allowed:
        msg = "Proposed move is not allowed. Incompatible path types and "
        msg += "propagation directions."
        logger.debug(msg)
        return 'SWD', ens0.paths[0], ens1.paths[0]  # Swap Wrong Direction

    # If allowed, the swap move is attempted
    msg = "Attempting swap of {} and {} paths with propdirs {} and {}."
    logger.debug(msg.format(path0_type, path1_type, propdir0, propdir1))

    # First create path0_new, then path1_new.
    # We will immediately reject the move if path0_new is not valid.

    # 1) new [i^+-] path from old [(i+1)^+-] path
    ph_overlap0, op_overlap0, sh0 = \
        cut_overlap_phasepoints(ens1, propdir1, side='right')
    # now we can propagate the phasepoint sh0 in the proposed direction
    if ens0.ens_type == 'PPTIS_0plusmin_primed':  # Automatically acceptable
        new_path_0 = Path(ph_overlap0, op_overlap0, ens0.id)
        status0 = "ACC"   
    else:
        ph_extend0, op_extend0 = [], []
        run_len = len(ph_overlap0)
        crossed = False
        run_worthy = True
        reverser0 = 1. if propdir1 == 'forwards' else -1.
        ph = (sh0[0], reverser0*sh0[1])
        while run_worthy:
            ph = ens0.engine.step(ph)
            op = ens0.orderparameter.calculate(ph)
            ph_extend0.append((ph[0], reverser0*ph[1]))
            op_extend0.append(op)
            run_len += 1
            LR_pos = check_position(op, ens0.intfs['L'], ens0.intfs['R'])
            if LR_pos in ['L', 'R']:
                run_worthy = False
                if LR_pos in ens0.end_conditions if reverser0 == 1. else \
                        ens0.start_conditions:
                    msg = f"Path crossed {LR_pos}, which is part of the"
                    msg+= "{}".format("end" if reverser0 == 1. else "start")
                    msg+= " conditions {}".format(ens0.end_conditions if \
                                reverser0 == 1. else ens0.start_conditions)
                    logger.debug(msg)
                    crossed = True
                    status0 = "ACC"
                else:
                    msg = f"Path crossed {LR_pos}, which is not part of the"
                    msg+= "{}".format("end" if reverser0 == 1. else "start")
                    msg+= " conditions {}".format(ens0.end_conditions if \
                                reverser0 == 1. else ens0.start_conditions)
                    logger.debug(msg)
                    logger.debug("Path hit the wrong interface.")
                    status0 = "FWI" if reverser0 == 1. else "BWI"
            if run_len >= ens0.max_len and not crossed:
                logger.debug(f"Path too long ({run_len} >= {ens0.max_len})")
                status0 = "FTL" if reverser0 == 1. else "BTL"

    if status0 != "ACC":
        logger.info("First propagation was not succussful. Reason: {}".format(
            status0))
        if reverser0 == -1.:
            trial0 = Path(ph_extend0[::-1] + ph_overlap0,
                          op_extend0[::-1] + op_overlap0,
                          ens0.id)
        else:
            trial0 = Path(ph_overlap0 + ph_extend0,
                          op_overlap0 + op_extend0,
                          ens0.id)
        return status0, trial0, ens1.paths[0]

    # 2) new [(i+1)^+-] path from old [i^+-] path
    ph_overlap1, op_overlap1, sh1 = \
        cut_overlap_phasepoints(ens0, propdir0, side='left')
    # now we can propagate the phasepoint sh1 in the proposed direction
    run_len = len(ph_overlap1)
    crossed = False
    run_worthy = True
    reverser1 = 1. if propdir0 == 'forwards' else -1.
    ph = (sh1[0], reverser1*sh1[1])
    ph_extend1, op_extend1 = [], []
    while run_worthy:
        ph = ens1.engine.step(ph)
        op = ens1.orderparameter.calculate(ph)
        ph_extend1.append((ph[0], reverser1*ph[1]))
        op_extend1.append(op)
        run_len += 1
        LR_pos = check_position(op, ens1.intfs['L'], ens1.intfs['R'])
        if LR_pos in ['L', 'R']:
            run_worthy = False
            if LR_pos in ens1.end_conditions if reverser1 == 1. else \
                    ens1.start_conditions:
                msg = f"Path crossed {LR_pos}, which is part of the"
                msg+= "{}".format("end" if reverser1 == 1. else "start")
                msg+= " conditions {}".format(ens1.end_conditions if \
                            reverser1 == 1. else ens1.start_conditions)
                logger.debug(msg)
                crossed = True
                status1 = "ACC"
            else:
                msg = f"Path crossed {LR_pos}, which is not part of the"
                msg+= "{}".format("end" if reverser1 == 1. else "start")
                msg+= " conditions {}".format(ens1.end_conditions if \
                            reverser1 == 1. else ens1.start_conditions)
                logger.debug(msg)
                logger.debug("Path hit the wrong interface.")
                status1 = "FWI" if reverser1 == 1. else "BWI"
        if run_len >= ens1.max_len and not crossed:
            logger.debug(f"Path too long ({run_len} >= {ens1.max_len})")
            status1 = "FTL" if reverser1 == 1. else "BTL"

    if status1 != "ACC":
        logger.info("Second propagation was not succussful. Reason: {}".format(
            status1))
        if reverser1 == -1.:
            trial1 = Path(ph_extend1[::-1] + ph_overlap1,
                          op_extend1[::-1] + op_overlap1,
                          ens1.id)
        else:
            trial1 = Path(ph_overlap1 + ph_extend1,
                          op_overlap1 + op_extend1,
                          ens1.id)
        return status1, trial0, trial1

    # If we reached this point, we have two new paths. We now check whether they
    # satisfy the crossing conditions.
    if reverser0 == -1.:
        new_path_0 = Path(ph_extend0[::-1] + ph_overlap0,
                          op_extend0[::-1] + op_overlap0,
                          ens0.id)
    else:
        new_path_0 = Path(ph_overlap0 + ph_extend0,
                          op_overlap0 + op_extend0,
                          ens0.id)
    if reverser1 == -1.:
        new_path_1 = Path(ph_extend1[::-1] + ph_overlap1,
                          op_extend1[::-1] + op_overlap1,
                          ens1.id)
    else:
        new_path_1 = Path(ph_overlap1 + ph_extend1,
                          op_overlap1 + op_extend1,
                          ens1.id)

    if not ens0.check_path(new_path_0):
        logger.warning("New path does not satisfy ensemble conditions.")
        return "NCR", new_path_0, new_path_1
    if not ens1.check_cross(new_path_1):
        logger.warning("New path does not satisfy ensemble conditions.")
        return "NCR", new_path_0, new_path_1
    else:
        logger.debug("New paths are acceptable.")
        return "ACC", new_path_0, new_path_1
    
def cut_overlap_phasepoints(ens, propdir, side, level=0):
    """ Cut the phasepoints in the overlapping region of two PPTIS ensembles.

    Parameters
    ----------
    ens: :py:class:`Ensemble` object
        Ensemble whose path is cut
    propdir: str
        Propagation direction of the path. Forwards or backwards
    side: string
        This is either 'left' or 'right', and denotes the side from which
        the path originates. left: [i^+-] path to be propagated into [i+1^+-],
        right: [(i+1)^+-] path to be propagated into [i^+-].

    Returns
    -------
    phasepoints_overlap : list of phasepoints
        The phasepoints in the overlap region
    shootpoint : phasepoint
        The phasepoint from which the propagation will start.

    Notes
    -----
    Note that here we need to re-reverse paths that are reversed,
    as we are not using the 'paste-paths' function from pyretis...

    Note that this function assumes that the proposed combination of 
    propdir and side makes sense for ens.last_path...

    """
    # intf_M defines when to stop cutting phasepoints, starting from a L or R
    # interface. For now, this only differs from M in the case of a [0^+-']
    if ens.ens_type == 'PPTIS_0plusmin_primed':
        intf_M = ens.intfs['L']
    elif ens.ens_type == 'PPTIS_Nplusmin_primed':
        intf_M = ens.intfs['R']
    else:
        intf_M = ens.intfs['M']

    phasepoints_overlap = []
    orders_overlap = []
    include_shootpoint = True  # standard behaviour

    if side == 'right':
        if propdir == 'backwards':
            shoot_point = ens.paths[level].phasepoints[0]
            if include_shootpoint:
                phasepoints_overlap.append(shoot_point)
                orders_overlap.append(ens.paths[level].orders[0])
            phase_points = ens.paths[level].phasepoints[1:]
            orders = ens.paths[level].orders[1:]
            for phase_point, order in zip(phase_points, orders):
                phasepoints_overlap.append(phase_point)
                orders_overlap.append(order)
                if order[0] > intf_M:  # if > M, we stop cutting
                    break
        elif propdir == 'forwards':
            shoot_point = ens.paths[level].phasepoints[-1]
            if include_shootpoint:
                phasepoints_overlap.append(shoot_point)
                orders_overlap.append(ens.paths[level].orders[-1])
            phase_points = ens.paths[level].phasepoints[:-1]
            orders = ens.paths[level].orders[:-1]
            for phase_point, order in zip(reversed(phase_points),
                                          reversed(orders)):
                phasepoints_overlap.append(phase_point)
                orders_overlap.append(order)
                if order[0] > intf_M:
                    break
            # re-reverse the phasepoints and orders
            phasepoints_overlap = phasepoints_overlap[::-1]
            orders_overlap = orders_overlap[::-1]
    elif side == 'left':
        if propdir == 'backwards':
            shoot_point = ens.paths[level].phasepoints[0]
            if include_shootpoint:
                phasepoints_overlap.append(shoot_point)
                orders_overlap.append(ens.paths[level].orders[0])
            phase_points = ens.paths[level].phasepoints[1:]
            orders = ens.paths[level].orders[1:]
            for phase_point, order in zip(phase_points, orders):
                phasepoints_overlap.append(phase_point)
                orders_overlap.append(order)
                if order[0] < intf_M:
                    break
        elif propdir == 'forwards':
            shoot_point = ens.paths[level].phasepoints[-1]
            if include_shootpoint:
                phasepoints_overlap.append(shoot_point)
                orders_overlap.append(ens.paths[level].orders[-1])
            phase_points = ens.paths[level].phasepoints[:-1]
            orders = ens.paths[level].orders[:-1]
            for phase_point, order in zip(reversed(phase_points),
                                          reversed(orders)):
                phasepoints_overlap.append(phase_point)
                orders_overlap.append(order)
                if order[0] < intf_M:
                    break
            # re-reverse the phasepoints and orders
            phasepoints_overlap = phasepoints_overlap[::-1]
            orders_overlap = orders_overlap[::-1]
    return phasepoints_overlap, orders_overlap, shoot_point