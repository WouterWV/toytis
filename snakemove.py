import numpy as np
import logging

from path import Path
from funcs import plot_paths, overlay_paths

import matplotlib.pyplot as plt

from moves import cut_LR_to_M, cut_extremal_phasepoints, propagate,\
    cut_overlap_phasepoints

logger = logging.getLogger(__name__)
logger.addHandler(logging.NullHandler())

def snake_move(ensembles, Lmax=10, simcycle=0, tail_id=None, can_eat_tail=True):
    """ Performs the snake move. 
    For now, detailed balance is broken. 
    I will have to either: 
    A) Keep the same format, but:
        a) use two parallel pathensembles for each ensemble
        b) use weights for the paths
    B) Only allow for tail-eating snakes. Weights are attributed to all paths, 
    where w = 1 / N_possible_circular_snakes. This will be fun to implement!


    The snake move uses paths that are older than the last_path. 

    The algorithm is as follows:

    1. Choose a random ensemble where the snake spawns. This is the tail-
    ensemble of the snake E_tail. The length of the snake is now 1 (L=1).

    2. Propagate the last accepted path of E_tail forwards or backwards 
    into a neighbouring ensemble. This ensemble is the head-ensemble of 
    the snake E_head. The direction of propagation is chosen randomly. L=2.

    3. While L < Lmax and not eats_own_tail:
        
        3.1. Propagate the path at the **lowest available level** of
        E_head forwards or backwards into a neighbouring ensemble. The 
        lowest available level denots the lowest E_head.paths index that
        has not yet been used to propagate the snake.
        This ensemble is the new head-ensemble of the snake E_head. 
        The direction of propagation is chosen randomly. L += 1.

        3.2. If E_head == E_tail, eats_own_tail = True. Else, continue.

    4. If not eats_own_tail:
            
        4.1. For body-ensembles (i.e. all the ensembles the snake has 
        visited except for the tail- and head-ensembles):
        Call N_i the number of times the snake visited a body ensemble E_i. 
        The N_i-th path generated by the snake move becomes the last
        accepted path of E_i. The (N_i-1)-th path generated by the snake
        move becomes the second-last accepted path, etc. 
        The last-accepted path of the old superstate is thus lost. 
        NET GAIN of paths: 0

        4.2. For the tail-ensemble: Remove the last accepted path of E_tail,
        and cascade the older paths upwards: the second-last accepted path
        becomes the last accepted path, the third-last accepted path becomes
        the second-last accepted path, etc.
        NET GAIN of paths: -1

        4.3. For the head-ensemble: We do the same as for the body-ensembles
        where we treat the last-accepted path of the old superstate as 
        firstly generated path of E_head. 
        NET GAIN of paths: +1

    5. If eats_own_tail:

        5.1. Body-ensembles: Same as for non-eats_own_tail.
        Net GAIN of paths: 0

        5.2. Tail ensemble == head ensemble, and this ensemble is (by
        definition) visited twice. The newly generated path in E_headtail
        becomes the new last accepted path, and the previous last-accepted
        path becomes the new second-last-accepted path. 
        NET GAIN of paths: 0

    """
    # Things we will have to track:
    visits = np.zeros(len(ensembles), dtype=int)
    L = 0
    eats_own_tail = False
    snake_skeleton = []
    # Elements of snake_paths are lists of tuples (status, trial) of the 
    # paths generated by the snake move in the corresponding ensemble.
    snake_paths = [[] for _ in range(len(ensembles))]

    # Step 1: Choose a random ensemble where the snake spawns. This is the
    # tail-ensemble of the snake E_tail. The length of the snake is now 1.
    exclude_from_spawn = False
    if tail_id is not None:
        E_tail = ensembles[tail_id]
    elif exclude_from_spawn:
        # We cannot let the snake spawn in primed ensembles.
        spawnable_ids = []
        for ens in ensembles: 
            if ens.ens_type not in ["PPTIS_Nplusmin_primed",
                                    "PPTIS_0plusmin_primed"]:
                spawnable_ids.append(ens.id)
        spawnid = np.random.choice(spawnable_ids)
        E_tail = ensembles[spawnid]
    else:
        E_tail = np.random.choice(ensembles)
    L += 1
    visits[E_tail.id] += 1
    snake_skeleton.append(E_tail.id)
    logger.info("Snake spawned in ensemble {} ({})".format(E_tail.name,
                                                           E_tail.id))

    # Step 2: Propagate the last accepted path of E_tail forwards or
    # backwards into a neighbouring ensemble.
    reverse, E_head = snake_waggle(ensembles, E_tail)
    status, trial = snake_propagator(ensembles, E_tail, E_head, reverse)
    # if the logger is set to debug, we plot the trial path, and the path
    # from which it was built.
    if logger.getEffectiveLevel() == logging.DEBUG:
        import matplotlib.pyplot as plt
        fig, ax = plt.subplots()
        overlapids = overlay_paths(E_tail.paths[0], [trial])
        startids = [0,overlapids[0][1]] if reverse == 1\
            else [overlapids[0][2],0]
        ppaths = [E_tail.paths[0], trial]
        plot_paths(ppaths, ax=ax, start_ids=startids)
        ax.set_title("Prop {}: from {} (level {}) to {}".format(
            L, E_tail.name, 0, E_head.name))
        fig.show()

    # Update snake information
    snake_paths[E_head.id].append((status, trial))
    visits[E_head.id] += 1
    L += 1
    snake_skeleton.append(E_head.id)
    logger.info("Wiggle status: {}. L = {}".format(status, L))

    # Step 3: While L < Lmax and not eats_own_tail:
    while L < Lmax and not eats_own_tail:
        level = visits[E_head.id] - 1
        E_head_old = E_head
        reverse, E_head = snake_waggle(ensembles, E_head, level=level)
        if E_head.id == E_tail.id and can_eat_tail:
            eats_own_tail = True
            logger.info("Snake will eat its own tail!")
        status, trial = snake_propagator(ensembles, E_head_old, E_head,
                                         reverse, level=level)
        # if the logger is set to debug, we plot the trial path, and the path
        # from which it was built.
        if logger.getEffectiveLevel() == logging.DEBUG:
            fig, ax = plt.subplots()
            overlapids = overlay_paths(E_head_old.paths[level], [trial])
            startids = [0,overlapids[0][1]] if reverse == 1\
                else [overlapids[0][2],0]
            ppaths = [E_head_old.paths[level], trial]
            plot_paths(ppaths, ax=ax, start_ids=startids)
            ax.set_title("Prop {}: from {} (level {}) to {}".format(
                L, E_head_old.name, level, E_head.name))
            fig.show()
                
        # Update snake information
        snake_paths[E_head.id].append((status, trial))
        visits[E_head.id] += 1
        L += 1
        snake_skeleton.append(E_head.id)
        logger.info("Wiggle status: {}. L = {}".format(status, L))

    logger.info("Snake move finished with L = {} (L_max = {}).".format(L, Lmax))
    logger.info("Doing bookkeeping")
    # step 4: Bookkeeping
    # 4.1.: Tail-ensemble: Remove the last accepted path of E_tail, 
    # which is the first path in E_tail.paths, and cascade upwards
    # TODO: do I also have to update the data for this pop? Right now, I'm not
    # discriminating whether we have tail-eating or not, and then it seems
    # like I have to update the data (to be similar to non-tail-eating).
    # It's easy, we just bookkeep the last N accepted paths of each ensemble,
    # This is, however, a completely different approach of updating data, and 
    # you'll have to update the other moves as well... Well, not necessarily,
    # after every move you can just add a 'update_N_paths function", which
    # saves the data of the last N paths of each ensemble to a second 
    # pathensemble2.txt file :) of course, we can also just update the weights
    # of the existing paths, but I think this clashes with the mindset of also
    # putting rejected paths in the pathensemble.txt file. I think in post
    # processing, we can update the path weights by amount of occurrence in the 
    # staggered pathensembe2.txt file, afther which we create a new pathensemble
    # file which only contains ACC paths with integer weights >=1. Aighty aight.
    
    # First busieth deinselbs met de one-only sliz.
    # Here, the paths will end up in the correct hierarchy, and then we can 
    # create the staggered pathensemble version afterwards. We just pop and 
    # add the paths in the way they were itended. Then we update paths for 
    # the ensembles that were visited. Easy as that.
    logger.info("Snake move done!")
    logger.info("Snake skeleton: {}".format(snake_skeleton))
    logger.info("Snake paths: {}".format(snake_paths))
    logger.info("Snake visits: {}".format(visits))
    logger.info("Ensemble ids: {}".format([ens.id for ens in ensembles]))
    logger.info("Snake eats own tail: {}".format(eats_own_tail))
    logger.info("Snake length: {}".format(L))
    logger.info("Snake head: {}".format(E_head.name))
    logger.info("Snake tail: {}".format(E_tail.name))
    # 1) E_tail pops its latest path: net loss of one path here
    E_tail.paths.pop(0)
    # 2) E_head gets a placeholder at position 0: net gain of one path here
    E_head.paths.insert(0, None)
    # 3) Body-ensembles:
    for i, ens in enumerate(ensembles):
        if i == E_tail.id:
            # Tail ensemble can max have one newly generated path in the case
            # of tail-eating. If this is the case, we can add the newly 
            # generated path. If not, continue
            if eats_own_tail:
                E_tail.paths[0] = snake_paths[i][0][1]
        else:
            for j in range(visits[i]):
                ens.paths[visits[i]-j-1] = snake_paths[i][j][1]
            #ens.update_data(*snake_paths[i][j], "SB", simcycle)
    # 4) Updating data. 
    # TODO: Do I only update the data of the ensembles that the snake has 
    # visited? Or do I add null moves in the unvisited ensembles? I think the 
    # latter is the correct one, as we don't have a 'systematic' way of 
    # performing the snake move in all ensembles (which was the chase for the 
    # shooting and swapping 'array' moves...) 
    # New flags:
    # 1) SB: snake body
    # 2) SH: snake head (no tail-eating)
    # 3) ST: snake tail (no tail-eating)
    # 4) SE: snake eats own tail
    # 5) S0: not visited, null move
    for i, ens in enumerate(ensembles):
        if i == E_tail.id:
            if eats_own_tail:
                flag = "SE"
            else:
                flag = "ST"
        elif i == E_head.id:
            flag = "SH"
        elif i in snake_skeleton:
            flag = "SB"
        else:
            flag = "S0"
        ens.update_data("ACC", ens.paths[0], flag, simcycle, update_paths=False)
        if i in snake_skeleton and ens.save_pe2:
            ens.write_to_pe2(gen=flag)  # 5) Updating pathensemble2.txt files
    # 
    # # for the ensembles visited by the snake, we update pathensemble2.txt
    # # with the newly generated paths. For the other ensembles, we do nothing
    # for i, ens in enumerate(ensembles):
    #     if i in snake_skeleton and ens.save_pe2:
    #         ens.write_to_pe2(gen='SN')
    # we return snake information, for debugging purposes
    return snake_skeleton, snake_paths, visits

def snake_waggle(ensembles, E_head, level=0):
    """Snake wiggles from E_head to a neighbouring ensemble, which becomes
    the new E_head. To propagate, we will need a propagation direction, the 
    new E_head. 

    Parameters
    ----------
    ensembles : list of :py:class:`Ensemble` objects
        List of all ensembles in the system.
    E_head : :py:class:`Ensemble` object
        The ensemble from which the snake will propagate.
    level : int
        Level at which the snake propagates. Level 0 is the last-accepted path,
        level 1 is the second-last accepted path, etc.

    Returns
    -------
    reverse : int
        Reverse factor, either 1 or -1.
    new_E_head : :py:class:`Ensemble` object
        The new ensemble that becomes the snake head.

    """
    propdir = np.random.choice(["forwards", "backwards"])
    reverse = -1 if propdir == "backwards" else 1
    LR_mappu = 0 if propdir == "backwards" else -1
    ptype = E_head.get_ptype(E_head.paths[level])
    L_or_R = ptype[LR_mappu]
    new_E_head_id = E_head.id + 1 if L_or_R == "R" else E_head.id - 1
    new_E_head = ensembles[new_E_head_id]
    # The code below does not work as L*L paths can arise in [1+-] ensemble.
    # # With the following if statement, we make sure that the snake does not
    # # wiggle into the primed ensembles.
    # if new_E_head.ens_type == "PPTIS_0plusmin_primed" or\
    #         new_E_head.ens_type == "PPTIS_Nplusmin_primed":
    #     new_E_head_id =\
    #         new_E_head.id + 1 if L_or_R == "R" else new_E_head.id - 1
    #     new_E_head = ensembles[new_E_head_id]
    msg=f"Snake wiggles {propdir} on an {ptype} path at level {level} from "
    msg+=f"{E_head.name} ({E_head.id}) to {new_E_head.name} ({new_E_head.id})"
    logger.debug(msg)
    return reverse, new_E_head

def snake_propagator(ensembles, E_head_old, E_head, reverse, level=0):
    """ After the snake arrives in an ensemble, we propagate the lowest-
    available path in that ensemble forwards or backwards.
    
    Parameters
    ----------
    ensembles : list of :py:class:`Ensemble` objects
        List of all the ensembles in the simulation
    E_head_old : :py:class:`Ensemble` object
        Ensemble where the snake was before it propagated to E_head
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake currently is
    prop_dir : str
        Direction of propagation, either "forwards" or "backwards"
    reverse : float
        Whether to propagate forwards (1.) or backwards (-1.)

    """
    if E_head_old.id == 0 and E_head.id == 1:
        return snake_propagate_no_overlap(E_head_old, E_head, reverse,
                                          level=level)
    elif E_head_old.id == 1 and E_head.id == 0:
        return snake_propagate_no_overlap(E_head_old, E_head, reverse,
                                          level=level)
    elif E_head_old.id == 2 and E_head.id == 1:
        return snake_propagate_full_overlap(E_head_old, E_head, reverse,
                                            level=level)
    elif E_head_old.id == len(ensembles) - 1 and\
        E_head.id == len(ensembles) - 2:
        return snake_propagate_no_overlap(E_head_old, E_head, reverse,
                                          level=level)
    elif E_head_old.id == len(ensembles) - 2 and\
        E_head.id == len(ensembles) - 1:
        return snake_propagate_no_overlap(E_head_old, E_head, reverse,
                                          level=level)
    elif E_head_old.id == len(ensembles) - 3 and\
        E_head.id == len(ensembles) - 2:
        return snake_propagate_full_overlap(E_head_old, E_head, reverse,
                                            level=level)
    else:
        return snake_propagate(E_head_old, E_head, reverse, level=level)

def snake_propagate(E_head_old, E_head, reverse,
                    level=0):
    """ After the snake arrives in an ensemble, we propagate the lowest-
    available path in that ensemble forwards or backwards.
    
    Parameters
    ----------
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake currently is
    reverse : float
        Whether to propagate forwards (1.) or backwards (-1.)

    """
    ph_overlap, op_overlap, sh = \
        cut_LR_to_M(E_head_old, reverse, level=level)
    maxlen_prop = E_head.max_len - len(ph_overlap)
    status, trial_tuple = propagate(E_head, sh, reverse, maxlen_prop)
    if reverse == -1:
        trial = Path(trial_tuple[0] + ph_overlap, trial_tuple[1] + op_overlap,
                     trial_tuple[2])
    else:
        trial = Path(ph_overlap + trial_tuple[0], op_overlap + trial_tuple[1],
                     trial_tuple[2])
    assert E_head.check_path(trial), "Propagated path is not valid"
    return status, trial



def snake_propagate_no_overlap(E_head_old, E_head, reverse, level=0):
    """The snake is in the [0^-'] ensemble, and it has been decided
    to propagate towards the new E_head == [0^+-'] ensemble. We don't have
    an overlap region in this case, and we perform half of the swap_zero move.
    
    Parameters
    ----------
    E_head_old : :py:class:`Ensemble` object
        Ensemble where the snake was before it propagated to E_head ([0^-'])
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake currently is ([0^+-'])
    prop_dir : str
        Direction of propagation, either "forwards" or "backwards"
    neighb_side : str
        Side from which we cut the overlap phasepoints: not needed here.
    reverse : float
        Whether to propagate forwards (1.) or backwards (-1.)

    """
    # Get the two phasepoints that will be copied
    ph_overlap, op_overlap, sh = cut_extremal_phasepoints(E_head_old, reverse,
                                                          level=level)
    maxlen_prop = E_head.max_len - 2
    status, trial_tuple = propagate(E_head, sh, reverse, maxlen_prop)
    if reverse == -1:
        trial = Path(trial_tuple[0] + ph_overlap, trial_tuple[1] + op_overlap,
                     trial_tuple[2])
    else:
        trial = Path(ph_overlap + trial_tuple[0], op_overlap + trial_tuple[1],
                     trial_tuple[2])
    # make a figure of the trial path and the path from which it was built
    if not E_head.check_path(trial):
        fig, ax = plt.subplots()
        overlapids = overlay_paths(E_head_old.paths[level], [trial])
        startids = [0,overlapids[0][1]] if reverse == 1\
            else [overlapids[0][2],0]
        ppaths = [E_head_old.paths[level], trial]
        plot_paths(ppaths, ax=ax, start_ids=startids)
        ax.set_title("Prop: from {} (level {}) to {}".format(E_head_old.name, level, E_head.name))
        fig.show()
    assert E_head.check_path(trial), "Propagated path is not valid"
    return status, trial


## OLDER ONES ## 
def snake_wiggle(ensembles, E_head, level=0):
    """Snake wiggles from E_head to a neighbouring ensemble, which becomes
    the new E_head. We get a propagation direction, the side from which we 
    cut the overlap path, and the reverse factor. 
    
    Parameters
    ----------
    ensembles : list of :py:class:`Ensemble` objects
        List of all the ensembles in the simulation
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake currently is
    level : int
        Level at which the snake propagates. Level 0 is the last-accepted path, 
        level 1 is the second-last accepted path, etc.

    Returns
    -------
    prop_dir : str
        Direction of propagation, either "forwards" or "backwards"
    neighb_side : str
        Side from which we cut the overlap phasepoints. This is either "left"
        or "right". Left: we cut the overlap path from ensemble i to create a 
        path in ensemble i+1. Right: we cut the overlap path from ensemble i
        to create a path in ensemble i-1.
    reverse : float
        Whether to propagate forwards (1.) or backwards (-1.)
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake is now
    
    """
    prop_dir = np.random.choice(["forwards", "backwards"])
    reverse = -1 if prop_dir == "backwards" else 1
    ptype = E_head.get_ptype(E_head.paths[level])
    prop_dict = {"loc" : {"forwards": -1,  # take first/last of ptype (e.g. LMR)
                          "backwards": 0},
                "side" : {"L": "right",  # from which side do we cut overlap?
                          "R": "left"},
                "neighb_idx" : {"right": -1,  # new path in id + or - 1
                                "left": 1}
                }
    neighb_loc = ptype[prop_dict["loc"][prop_dir]]
    neighb_side = prop_dict["side"][neighb_loc]
    E_head = ensembles[E_head.id + prop_dict["neighb_idx"][neighb_side]]
    return prop_dir, neighb_side, reverse, E_head


def snake_propagate_full_overlap(E_head_old, E_head, reverse, level=0):
    """Snake is propagated from ensemble E_head_old to E_head. The phasespace 
    of E_head is a subspace of the phasespace of E_head_old, and if we 
    entered this propagation mode, than the new path can just be cut out of 
    the old path. 
    
    Parameters
    ----------
    E_head_old : :py:class:`Ensemble` object
        Ensemble where the snake was before it propagated to E_head
    E_head : :py:class:`Ensemble` object
        Ensemble where the snake currently is
    level : int
        Level of the path to cut. Level 0 is the last-accepted path, level 1
        is the second-last accepted path, etc.

    """
    ph_overlap, op_overlap, sh = \
        cut_LR_to_M(E_head_old, reverse, level=level)
    # This cut-out path should already satisfy E_head pathensemble criteria
    trial = Path(ph_overlap, op_overlap, E_head.id)
    # Check whether the path meets the criteria
    # plot the path
    # fig, ax = plt.subplots()
    # ax.plot([op[0] for op in trial.orders])
    # ax.set_title("Snake propagation from {} to {}".format(
    #     E_head_old.name, E_head.name))
    # fig.show()
    assert E_head.check_path(trial), "Path does not meet criteria"
    return "ACC", trial


def forced_extension(ensembles, idx):
    """Perform a forced extension of a path in PPTIS ensemble idx. This extends
    the path forwards/backwards in time until the path satisfies the conditions 
    of the ensemble it is propagated into. To obey detailed balance, we will 
    have to pop the last path of ensemble idx, and insert the newly generated
    path into ensemble idx+-1 (depending on which direction the path is 
    propagated into). In essence, this is a snake move of length L=2.
    
    Parameters
    ----------
    ensembles : list of :py:class:`Ensemble` objects
        List of ensembles present in the simulation
    idx : int
        Index of the ensemble whose path is extended

    Returns
    -------
    status : str
        Status of the propagation.
    trial_tuple : tuple
        tuple of (phs, ops, ens.id) of the trial path
    """
    # At first, the move just starts as a normal repptis_swap move. Instead of 
    # checking whether the move is allowed, we just propagate the path in the 
    # chosen propagation direction. 
    reverse, E_head = snake_waggle(ensembles, ensembles[idx], level=0)
    status, trial = snake_propagator(ensembles, ensembles[idx], E_head,
                                           reverse, level=0)
    # Let's plot the level 0 and level 1 paths of both ensembles before and 
    # after this move has been finished. 
    # import matplotlib.pyplot as plt
    # fig, ax = plt.subplots()
    # l0paths = [ensembles[idx].paths[0], E_head.paths[0]]
    # l1paths = [ensembles[idx].paths[1], E_head.paths[1]]
    # l2paths = [ensembles[idx].paths[2], E_head.paths[2]]
    # plot_paths(l0paths, ax=ax, start_ids=[0,0], color="r")
    # plot_paths(l1paths, ax=ax, start_ids=[1000,1000], color="g")
    # plot_paths(l2paths, ax=ax, start_ids=[2000,2000], color="b")
    # ax.set_title("Before the forced extension...")
    # fig.show()
    # Let's do it again, but plot make two subplots, one for idx and one for head
    # fig, (ax1, ax2) = plt.subplots(1,2)
    # idxpaths = [ensembles[idx].paths[0], ensembles[idx].paths[1],
    #             ensembles[idx].paths[2]]
    # headpaths = [E_head.paths[0], E_head.paths[1], E_head.paths[2]]
    # plot_paths(idxpaths, ax=ax1, start_ids="staggered")
    # plot_paths(headpaths, ax=ax2, start_ids="staggered")
    # ax1.set_title("{}: Before the forced extension...".format(
    #     ensembles[idx].name))
    # ax2.set_title("{}: Before the forced extension...".format(
    #     E_head.name))
    # fig.show()
    # if True:
    #     import matplotlib.pyplot as plt
    #     fig, ax = plt.subplots()
    #     overlapids = overlay_paths(ensembles[idx].paths[0], [trial])
    #     startids = [0,overlapids[0][1]] if reverse == 1\
    #         else [overlapids[0][2],0]
    #     ppaths = [ensembles[idx].paths[0], trial]
    #     plot_paths(ppaths, ax=ax, start_ids=startids)
    #     ax.set_title("Prop: from {} (level {}) to {}".format(
    #         ensembles[idx].name, 0, E_head.name))
    #     fig.show()
    assert E_head.check_path(trial), "Path does not meet criteria..."

    return status, trial, E_head.id
